// Generated by CoffeeScript 2.3.2
(function() {
  var AsyncLock, LOG, LockHandler, MAX_PENDING, MAX_WAITTIME, Proxy, RETRIES, RETRY, domainReentrant, lockFile, lock_dir;

  Proxy = require("./Proxy");

  AsyncLock = require("async-lock");

  lockFile = require("lockfile");

  LOG = LoggerUtil.getLogger("LockHandler");

  MAX_WAITTIME = 120000; // 最大等待时间

  MAX_PENDING = 1000; // 最大处理任务

  domainReentrant = true; // 同域是否可重用

  RETRY = 100; // 重新尝试等待时间

  RETRIES = 100; // 重新尝试次数

  lock_dir = "/run/lock/temp"; // 使用文件锁机制，临时文件存放处

  mkdirp.sync(lock_dir);

  LockHandler = class LockHandler {
    constructor(param) {
      var opt1, opt2;
      param = param || {};
      opt1 = {
        timeout: param.timeout || MAX_WAITTIME,
        maxPending: param.pending || MAX_PENDING,
        domainReentrant: !!param.reentrant || domainReentrant
      };
      opt2 = {
        wait: param.timeout || MAX_WAITTIME,
        retryWait: param.retry || RETRY,
        retries: param.retries || RETRIES
      };
      param.pollPeriod && (opt2.pollPeriod = param.pollPeriod);
      param.stale && (opt2.stale = param.stale);
      this.asyncLock = new AsyncLock(opt1);
      this.lockFile = lockFile;
      this.lockFile.old_lock = this.lockFile.lock;
      this.lockFile.old_unlock = this.lockFile.unlock;
      this.lockFile.lock = (name, opts = opt2, callback) => {
        var filename;
        if (!name) {
          LOG.error("未输入锁键");
          return callback("未输入锁键");
        }
        filename = `${lock_dir}/${name}`;
        return this.lockFile.old_lock(filename, opts, callback);
      };
      this.lockFile.unlock = (name, callback) => {
        var filename;
        if (!name) {
          LOG.error("未输入锁键");
          return callback("未输入锁键");
        }
        filename = `${lock_dir}/${name}`;
        return this.lockFile.old_unlock(filename, callback);
      };
    }

  };

  module.exports = LockHandler;

}).call(this);
