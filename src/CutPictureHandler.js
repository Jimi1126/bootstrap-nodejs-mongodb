// Generated by CoffeeScript 2.3.2
(function() {
  /*
   *	对下载解析等操作后的图片进行裁剪操作
   */
  var CutPictureHandler, ExecHandler, Handler, LOG,
    indexOf = [].indexOf;

  Handler = require("./Handler");

  ExecHandler = require("./ExecHandler");

  LOG = LoggerUtil.getLogger("CutPictureHandler");

  CutPictureHandler = class CutPictureHandler extends Handler {
    init(bill) {
      var bill_block, block, doc_type, i, j, k, l, len, len1, len2, msg, ref, ref1, ref2, ref3, t, tmpl, v;
      bill.blocks = [];
      doc_type = (ref = bill.source.docs) != null ? ref[0] : void 0;
      tmpl = null;
      ref1 = this.data.conf.bill.templates || this.data.conf.bill.template || [];
      for (j = 0, len = ref1.length; j < len; j++) {
        t = ref1[j];
        if (indexOf.call(t.docs, doc_type) >= 0) {
          tmpl = t;
          break;
        }
      }
      if (!tmpl) {
        msg = `${argv.project} 保单没有匹配的模板 ${bill.bill_name} ${bill.source.docs}`;
        LOG.warn(msg);
        return msg;
      }
      bill.template = tmpl.name;
      ref2 = tmpl.blocks;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        block = ref2[k];
        if (!block.pic_page) {
          LOG.warn(`${argv.project} 分块未指定图像页 ${bill.bill_name} ${tmpl.name} ${block.code} ${block.name} ${block.pic_page} ${bill.picture}`);
          continue;
        }
      }
      // pic = bill.picture?[block.pic_page - 1]
      // unless pic
      // 	msg = "#{argv.project} 分块缺少图像 #{bill.bill_name} #{tmpl.name} #{block.code} #{block.name} #{block.pic_page} #{bill.picture}"
      // 	LOG.warn msg
      // 	bill.status = "异常"
      // 	return "异常"
      bill_block = _.merge({}, block);
      bill_block.coordinate = bill_block.coordinate || [];
      ref3 = bill_block.coordinate;
      for (i = l = 0, len2 = ref3.length; l < len2; i = ++l) {
        v = ref3[i];
        v = parseFloat(v);
        if (v < -10) {
          v = 0;
        }
        if (v > 110) {
          v = 100;
        }
        bill_block.coordinate[i] = v;
      }
      bill.blocks.push(bill_block);
      return null;
    }

    handle(callback) {
      var billInfo, cmd, cut_stat, exec, ref;
      exec = new ExecHandler().queue_exec(3);
      cut_stat = {
        total: 0,
        success: 0,
        failure: 0
      };
      ref = this.data.billInfos;
      for (cmd in ref) {
        billInfo = ref[cmd];
        cut_stat.total += billInfo != null ? billInfo.length : void 0;
      }
      return async.eachOf(this.data.billInfos, (billInfo, cmd, cb1) => {
        var cut_path, rel_path;
        rel_path = "./download/" + cmd.substring(cmd.lastIndexOf("EPCOS") - 1);
        cut_path = rel_path.replace("download", "cut");
        LOG.info(`cut_path: ${cut_path}`);
        mkdirp.sync(cut_path);
        return async.each(billInfo, (bill, cb2) => {
          var cmd_fmt, msg;
          if (indexOf.call(bill.bill_name, "pdf") >= 0) {
            return cb2();
          }
          msg = this.init(bill);
          if (msg) {
            return cb2(msg);
          }
          cmd_fmt = this.data.conf.extract.crop || "gmic -v - %(src)s -crop[-1] %(x0)s%%,%(y0)s%%,%(x1)s%%,%(y1)s%% -o[-1] %(dst)s";
          return async.eachSeries(bill.blocks, (block, next) => {
            var dst, err, src, x0, x1, y0, y1;
            if (!(block.coordinate && block.pic_page)) {
              return next();
            }
            // for i in [0 .. 3]
            // 	block.coordinate[i] ?= 0
            // if block.coordinate[0] >= -2 and block.coordinate[0] <= 2 and 
            // 		block.coordinate[1] >= -2 and block.coordinate[1] <= 2 and
            // 		block.coordinate[2] >= -2 and block.coordinate[2] <= 2 and
            // 		block.coordinate[3] >= -2 and block.coordinate[3] <= 2
            // 	for i in [0 .. 3]
            // 		block.coordinate[i] *= 100
            // x0 = block.coordinate[0] ?= 0
            // y0 = block.coordinate[1] ?= 0
            // x1 = block.coordinate[2] ?= 100
            // y1 = block.coordinate[3] ?= 100
            // # 图像扩展
            // crop_expand = [10, 10]
            // x0 -= crop_expand[0]
            // # x0 = 0 if x0 < 0
            // y0 -= crop_expand[1]
            // # y0 = 0 if y0 < 0
            // x1 += crop_expand[0]
            // # x0 = 100 if x0 > 100
            // y1 += crop_expand[1]
            // # y1 = 100 if y1 > 100
            x0 = 80;
            y0 = 0;
            x1 = 100;
            y1 = 15;
            src = rel_path + bill.bill_name;
            dst = cut_path + bill.bill_name;
            try {
              cmd = sprintf.sprintf(cmd_fmt, {src, dst, x0, y0, x1, y1});
            } catch (error) {
              err = error;
              LOG.error(err);
              return next(err);
            }
            return exec(cmd, function(err, stdout, stderr, spent) {
              if (err) {
                bill.status = "异常";
                return next(err);
              }
              stdout = `${stdout}`.trim();
              stderr = `${stderr}`.trim();
              if (stdout.length > 0) {
                LOG.info(stdout);
              }
              if (stderr.length > 0) {
                LOG.info(stderr);
              }
              LOG.info(`${src} => ${dst} ${spent}ms`);
              cut_stat.success++;
              return next();
            });
          }, function(err) {
            var i, j, ref1;
            if (err) {
              if (bill.status === "异常") {
                return cb2(null);
              }
              LOG.error(err);
            }
            for (i = j = ref1 = bill.blocks.length - 1; (ref1 <= 0 ? j <= 0 : j >= 0); i = ref1 <= 0 ? ++j : --j) {
              if (bill.blocks[i].fields.length === 0) {
                bill.blocks.splice(i, 1);
              }
            }
            return cb2();
          });
        }, cb1);
      }, function() {
        cut_stat.failure = cut_stat.total - cut_stat.success;
        LOG.info(JSON.stringify(cut_stat));
        return callback.apply(this, arguments);
      });
    }

  };

  module.exports = CutPictureHandler;

}).call(this);
