// Generated by CoffeeScript 2.3.2
(function() {
  /*
   * 操作者接口
   * 通过继承EventEmitter的事件响应机制，实现观察者模式以及操作链模式
   * 一个操作者需要具备以下几点：
   * 执行操作的能力
   * 判断可以操作的能力
   * 当执行模式为串行操作也就是操作链模式，还需要知道相邻的上、下位操作者
   */
  var EventEmitter, Handler, HandlerProxy;

  EventEmitter = require('events').EventEmitter;

  HandlerProxy = require("./HandlerProxy");

  Handler = (function() {
    class Handler extends EventEmitter {
      constructor(data) {
        super();
        this.data = data;
        //# 注册next事件，用于通知下一位操作者
        this.on('next', function() {
          var callback, params, ref;
          [...params] = arguments;
          callback = params.pop();
          callback();
          if (this.nextHandler instanceof HandlerProxy || this.nextHandler instanceof Handler) {
            return this.nextHandler.execute.apply(this.nextHandler, params);
          } else {
            return (ref = this.nextHandler) != null ? typeof ref.apply === "function" ? ref.apply(this, params) : void 0 : void 0;
          }
        });
      }

      /*
       * 操作入口
       * 控制操作者的执行模式
       * 默认地，操作者会通过verify来判断的自身是否应该进行操作
       * 当可以进行操作时，调用handle主操作方法
       * 当操作完成后，通过触发next事件来通知下一位操作者
       * 你可在子类中覆盖该方法，以重新控制操作者的执行模式
       */
      execute() {
        var callback, cb, fparams, that;
        that = this;
        if (this.verify()) {
          [...fparams] = arguments;
          callback = fparams.pop();
          cb = function() {
            var params;
            [...params] = arguments;
            params.unshift("next");
            params.push(callback);
            return that.emit.apply(that, params);
          };
          fparams.push(cb);
          return this.handle.apply(this, fparams);
        } else {
          return this.emit('next', callback);
        }
      }

      //# 判断是否应该做操作，默认地返回true，具体判断逻辑请覆盖该方法
      verify() {
        return true;
      }

      //# 操作者所拥有的操作能力，子类必须实现该方法，以指定操作者的拥有的操作能力
      handle(callback) {
        throw "you must implement this method";
      }

      setLastHandler(lastHandler) {
        this.lastHandler = lastHandler;
      }

      setNextHandler(nextHandler) {
        this.nextHandler = nextHandler;
      }

    };

    Handler.prototype.lastHandler = null;

    Handler.prototype.nextHandler = null;

    return Handler;

  }).call(this);

  module.exports = Handler;

}).call(this);
