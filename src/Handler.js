// Generated by CoffeeScript 2.3.2
(function() {
  /*
   * 操作者接口
   * 通过继承EventEmitter的事件响应机制，实现观察者模式以及操作链模式
   * 一个操作者需要具备以下几点：
   * 执行操作的能力
   * 判断可以操作的能力
   * 当执行模式为串行操作也就是操作链模式，还需要知道相邻的上、下位操作者
   */
  var EventEmitter, Handler, HandlerProxy;

  EventEmitter = require('events').EventEmitter;

  HandlerProxy = require("./HandlerProxy");

  Handler = (function() {
    class Handler extends EventEmitter {
      constructor(data) {
        super();
        this.data = data;
        this.on('next', function() {
          var callback, params, ref;
          [...params] = arguments;
          callback = params.pop();
          callback();
          if (this.nextHandler instanceof HandlerProxy || this.nextHandler instanceof Handler) {
            return this.nextHandler.execute.apply(this.nextHandler, params);
          } else {
            return (ref = this.nextHandler) != null ? ref.apply(this, params) : void 0;
          }
        });
      }

      execute() {
        var callback, cb, fparams, that;
        that = this;
        if (this.verify()) {
          [...fparams] = arguments;
          callback = fparams.pop();
          cb = function() {
            var params;
            [...params] = arguments;
            params.unshift("next");
            params.push(callback);
            return that.emit.apply(that, params);
          };
          fparams.push(cb);
          return this.handle.apply(this, fparams);
        } else {
          return this.emit('next', callback);
        }
      }

      verify() {
        return true;
      }

      handle(callback) {
        throw "you must implement this method";
      }

      setLastHandler(lastHandler) {
        this.lastHandler = lastHandler;
      }

      setNextHandler(nextHandler) {
        this.nextHandler = nextHandler;
      }

    };

    Handler.prototype.lastHandler = null;

    Handler.prototype.nextHandler = null;

    return Handler;

  }).call(this);

  module.exports = Handler;

}).call(this);
