// Generated by CoffeeScript 2.3.2
(function() {
  var EnterContext, LOG, SocketIORouter;

  EnterContext = require("./EnterContext");

  LOG = LoggerUtil.getLogger("SocketIORouter");

  SocketIORouter = class SocketIORouter {
    router(socket) {
      socket.use(function(packet, next) {
        var index, ref, ref1, sessionid, str;
        str = socket.request.headers.cookie || "";
        index = str.indexOf("login=s%3A");
        if (index === -1) {
          return socket.emit("unlogin");
        }
        sessionid = str.substring(index + 10, index + 42);
        if ((typeof global !== "undefined" && global !== null ? (ref = global.sessions) != null ? ref[sessionid] : void 0 : void 0) && global.sessions[sessionid].cookie.maxAge > 0) {
          global.sessions[sessionid]._garbage = Date();
          global.sessions[sessionid].touch();
          return next();
        } else if (!((ref1 = global.sessions) != null ? ref1[sessionid] : void 0)) {
          return socket.emit("unlogin");
        } else {
          return socket.emit("overTime", true);
        }
      });
      socket.on("checkOverTime", function() {
        var checkOverTime, cookie, index, sessionid, str, that;
        that = this;
        str = this.request.headers.cookie || "";
        index = str.indexOf("login=s%3A");
        sessionid = str.substring(index + 10, index + 42);
        cookie = global.sessions[sessionid].cookie;
        checkOverTime = function() {
          return setTimeout(function() {
            if (cookie.maxAge > 0) {
              return checkOverTime(cookie.maxAge);
            } else {
              return that.emit("overTime", true);
            }
          }, cookie.maxAge);
        };
        return checkOverTime();
      });
      socket.on("refreshOverTime", function() {
        return socket.broadcast.emit("overTime", false);
      });
      socket.on("refreshEnterEntity", function(conf, callback) {});
      // context.refreshEnterEntity {data: conf}, (err, data)->
      //   if err
      //     LOG.error err
      //   else
      //     callback err
      // 释放录入实体
      socket.on("letEnterEntity", function(data, callback) {
        var entitys;
        if (!data || !data.project || !data.stage) {
          return typeof callback === "function" ? callback("failed") : void 0;
        }
        entitys = global.enter.entitys[data.project][data.stage];
        entitys.data.unshift((entitys.entering.splice(entitys.entering.findIndex(function(en) {
          return en._id.toString() === data._id;
        }), 1))[0]);
        return typeof callback === "function" ? callback("success") : void 0;
      });
      socket.on("submitEnter", function(data, callback) {
        var context, e, entitys, rankArr;
        if (!data || !data.project || !data.stage) {
          return typeof callback === "function" ? callback("failed") : void 0;
        }
        rankArr = ["new", "ocr", "op1", "op2", "op3", "op4"];
        try {
          entitys = global.enter.entitys[data.project][data.stage];
          entitys.entering.splice(entitys.entering.findIndex(function(en) {
            return en._id.toString() === data._id;
          }), 1);
          data.stage = rankArr[(rankArr.findIndex(function(r) {
            return r === data.stage;
          })) + 1];
          entitys = global.enter.entitys[data.project][data.stage];
          entitys && (entitys.isEmpty = false);
          context = new EnterContext();
          return context.update({
            col: "resultData",
            filter: {
              _id: data._id
            },
            setter: data
          }, callback);
        } catch (error) {
          e = error;
          return callback(e);
        }
      });
      return socket.on("disconnect", function() {});
    }

  };

  module.exports = SocketIORouter;

}).call(this);
